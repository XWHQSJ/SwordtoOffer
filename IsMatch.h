//
// Created by Wanhui on 2/21/20.
//

#ifndef SWORDTOOFFER_ISMATCH_H
#define SWORDTOOFFER_ISMATCH_H

/*
 * 剑指offer 19 正则表达式匹配
 *
 * 请实现一个函数用来匹配包含'. '和'*'的正则表达式。
 * 模式中的字符'.'表示任意一个字符，
 * 而'*'表示它前面的字符可以出现任意次（含0次）。
 * 在本题中，匹配是指字符串的所有字符匹配整个模式。
 * 例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但与"aa.a"和"ab*a"均不匹配。
 *
 * 示例 1:
 *
 * 输入:
 * s = "aa"
 * p = "a"
 * 输出: false
 * 解释: "a" 无法匹配 "aa" 整个字符串。
 *
 * 示例 2:
 *
 * 输入:
 * s = "aa"
 * p = "a*"
 * 输出: true
 * 解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素,
 * 在这里前面的元素就是 'a'。
 * 因此，字符串 "aa" 可被视为 'a' 重复了一次。
 *
 * 示例 3:
 *
 * 输入:
 * s = "ab"
 * p = ".*"
 * 输出: true
 * 解释: ".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。
 *
 * 示例 4:
 *
 * 输入:
 * s = "aab"
 * p = "c*a*b"
 * 输出: true
 * 解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个,
 * 'a' 被重复一次。因此可以匹配字符串 "aab"。
 *
 * 示例 5:
 *
 * 输入:
 * s = "mississippi"
 * p = "mis*is*p*."
 * 输出: false
 *
 * s 可能为空，且只包含从 a-z 的小写字母。
 * p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。
 * */


#include <string>

class Solution19 {
public:
    /*
     * 方法1 回溯法
     *
     * . 匹配单个任意字符，
     * * 匹配前一个字符的任意0个或多个，
     * 模式p中不带*时，字符串s与模式p直接比较就行，
     * 如果模式p带*，它会出现在一个字符的后面，
     * 如果p的第2个字符是*，有两种可能，
     * *匹配前一个字符0个或者*匹配前一个字符多个，
     * 匹配0个时，s回溯与p从第三个字符开始下一轮比较，
     * 匹配多个时，在满足s和p第1个字符配对的情况下,
     * s从第2个字符开始与p重新一轮匹配，
     * 如果p第2字符不是*，在满足s和p第1个字符配对的情况下,
     * 等于是普通匹配，继续下一轮匹配即可。
     * */
    bool isMatch(std::string s, std::string p);

    /*
     * 方法2 动态规划 自顶向下
     *
     * 状态：dp[i][j] 表示s的前i个是否能被p的前j个匹配
     * 转移方程：要求dp[i][j]的状态，可以从已知的dp[i-1][j-1]的状态，
     * 再加上s[i]，p[j]来判断。
     * 分3种情况考虑：
     * 1. p[j] == s[i] : dp[i][j] = dp[i-1][j-1]
     * 2. p[j] == '.' : dp[i][j] dp[i-1][j-1]
     * 3. p[j] = '*' : 分2种情况分析——
     *    1> p[i-1] != s[i] : dp[i][j] = dp[i][j-2]
     *    *前的字符与s的第i个字符不匹配，比如(ab, abc*),
     *    s[i]=ab与p[j-2]=ab是匹配的，此时c*可以匹配0个
     *    WARBing: (ab, abc**)=false，因为 (ab, a*)=false
     *    2> p[j-1] == s[i] || p[j-1] == '.' ：
     *    *前面的字符能匹配s[i]，或者*前面是 .
     *    比如(##b, ###b*)，或者(##b, ###.*),
     *    只要###匹配，后面一定匹配，所以要看b和b*前面的字符串是否匹配
     *    1) 多个字符匹配情况 : dp[i][j] = dp[i-1][j]
     *    2) 单个字符匹配情况 : dp[i][j] = dp[i][j-1]
     *       (该情况可省略，多字符包括单字符)
     *    3) 没有字符匹配情况 : dp[i][j] = dp[i][j-2]
     *
     * 总结：
     * 1. 如果 p[j] == s[i] : dp[i][j] = dp[i-1][j-1]
     * 2. 如果 p[j] == '.' : dp[i][j] = dp[i-1][j-1]
     * 3. 如果 p[j] == '*' :
     *   1> 如果 p[j-1] != s[i] : dp[i][j] = dp[i][j-2]
     *   2> 如果 p[j-1] == s[i] || p[j-1] == '.':
     *     1) dp[i][j] = dp[i-1][j]
     *     2) dp[i][j] = dp[i][j-2]
     * */
    bool isMatch2(std::string s, std::string p);

    // 动态规划 自底向上
    bool isMatch2_2(std::string s, std::string p);
};


#endif //SWORDTOOFFER_ISMATCH_H
