//
// Created by Wanhui on 3/22/20.
//

#ifndef SWORDTOOFFER_REVERSEPAIRS_H
#define SWORDTOOFFER_REVERSEPAIRS_H

/*
 * 剑指offer 51 数组中的逆序对
 *
 * 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。
 * 输入一个数组，求出这个数组中的逆序对的总数。
 *
 * 示例 1:
 *
 * 输入: [7,5,6,4]
 * 输出: 5
 *
 * 限制：
 * 0 <= 数组长度 <= 50000
 * */


#include <vector>

class Solution51 {
public:
    /*
     * 归并排序
     *
     * 使用归并排序的思想，在排序的过程中能够计数逆序对的个数：
     * 1. 将数组的数据不断的对半分，直到分解成长度为1的子数组；
     * 2. 把长度为1的子数组合并、排序，同时统计逆序对的个数；
     * 3. 把长度为2的子数组合并、排序，同时统计逆序对的个数；
     * 4. 依步骤2,3的操作对子数组不断合并、排序，返回最终的逆序对的个数。
     *
     * 这里重点是如何在归并排序合并过程中统计逆序对的个数：
     * 1. 合并两个子数组之前，子数组中的数是有序的；
     * 2. 使用两个指针，分别指向两个子数组的末尾元素；
     * 3. 比较指针指向的元素，如果前一个子数组指针指向的元素大于后一子数组指针指向的元素，
     *    则前一指针指向的数能够与后一指针指向的数前面的所以数组成逆序对（包括该数本身），
     *    将逆序对的个数加上后一指针指向数的索引加1，将较大的数复制到空数组中，前一子数组指针前移；
     * 4. 重复步骤3的比较，将两个子数组合并复制到一个数组中，同时也统计了逆序对的个数。
     * */
    int reversePairs(std::vector<int>& nums);

    // 归并排序
    void mergeSort(std::vector<int>& nums, std::vector<int>& copyNums, int start, int end, int& count);
};


#endif //SWORDTOOFFER_REVERSEPAIRS_H
