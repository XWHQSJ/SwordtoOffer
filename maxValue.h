//
// Created by Wanhui on 3/20/20.
//

#ifndef SWORDTOOFFER_MAXVALUE_H
#define SWORDTOOFFER_MAXVALUE_H

/*
 * 剑指offer 47 礼物的最大价值
 *
 * 在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。
 * 你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。
 * 给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？
 *
 * 示例 1:
 *
 * 输入:
 * [
 *   [1,3,1],
 *   [1,5,1],
 *   [4,2,1]
 * ]
 *
 * 输出: 12
 * 解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物
 *
 * 提示：
 * 0 < grid.length <= 200
 * 0 < grid[0].length <= 200
 * */



#include <vector>

class Solution47 {
public:
    /*
     * 动态规划
     *
     * 1. 将该问题分解为较小的子问题：
     *    因为是求矩阵从第一个点到最后一个点的礼物最大值，不妨先求第一点到第二点的礼物最大值，
     *    而第二点的礼物最大值，又由第二点礼物的值和第一点礼物的最大值的和决定。因为只能向右或向下走，
     *    所以取上面点或下面点中较大的礼物最大值再加上当前点的礼物值，即为当前点的礼物最大值。以此类推。
     * 2. 初始化
     *    定义礼物最大值矩阵，对应于礼物值矩阵。初始化礼物最大值矩阵的第一行和第一列。
     * 3. 状态转移方程：
     *    dp[i][j] = std::max(dp[i-1][j], dp[i][j-1]) + grid[i][j]
     * */
    int maxValue(std::vector<std::vector<int>> &grid);

    /*
     * 动态规划+空间压缩
     *
     * 根据上面动态规划的方法，可以将礼物最大值矩阵即状态矩阵压缩为一维矩阵。
     * 因为dp[j]的值在更新前仍然为该点上面点的礼物最大值，所以将dp[j]与dp[j-1]比较，
     * 和dp[i-1][j]与dp[i][j-1]的比较结果是相同的。
     * 所以状态转移方程修改为：
     * dp[j + 1] = std::max(dp[j], dp[j + 1]) + grid[i][j];
     *
     * 注意：如果状态转移方程修改为：
     * dp[j] = std::max(dp[j], dp[j - 1]) + grid[i][j];
     * 需要初始化dp[j]的值，并且在遍历礼物矩阵时也要初始化左侧的值，即：
     * dp[j] = dp[j-1] + grid[0][j]     // 初始化时，0 <= j < n
     * dp[0] += dp[i][0]                // 遍历i时， 1 <= i < m
     * */
    int maxValue2(std::vector<std::vector<int>> &grid);
};


#endif //SWORDTOOFFER_MAXVALUE_H
