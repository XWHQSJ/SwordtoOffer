//
// Created by Wanhui on 3/25/20.
//

#ifndef SWORDTOOFFER_LASTREMAINING_H
#define SWORDTOOFFER_LASTREMAINING_H

/*
 * 剑指offer 62 圆圈中最后剩下的数字
 *
 * 0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。
 * 求出这个圆圈里剩下的最后一个数字。
 *
 * 例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，
 * 则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。
 *
 * 示例 1：
 *
 * 输入: n = 5, m = 3
 * 输出: 3
 *
 * 示例 2：
 *
 * 输入: n = 10, m = 17
 * 输出: 2
 *
 * 限制：
 * 1 <= n <= 10^5
 * 1 <= m <= 10^6
 * */


class Solution62 {
public:
    /*
     * 环形链表 O(mn) 超时
     *
     * 因为要删除第m个数，所以使用链表是比较合适的方式。
     * 当遍历链表节点时，循环查找第m个节点，删除第m个节点，继续循环。
     * */
    int lastRemaining(int n, int m);

    /*
     * 环形链表优化 O(n2) 超时
     *
     * 通过模运算可以避免使用循环查找第m个节点的索引。
     * 因为计算指针位置时，链表查找仍然是线性的，所以时间复杂度为O(n2)。
     * */
    int lastRemaining2(int n, int m);

    /*
     * 数学方法 O(n)
     *
     * 1. 首先定义n个数围成的圈每次删除第m个数剩下的数为方程f(n, m)。在n个数中，第一个被删除的数是(m-1)%n。
     * 记(m-1)%n = k，则删除k后剩下的n-1个数分别为: 0,1,...,k-1,k+1,...,n-1，下次删除从k+1开始计数。
     * 相当于从k+1重排剩下的数为: k+1,...,n-1,0,1,...,k-1。
     * 2. 再定义删除了k的重排序列的方程为f'(n-1, m)，因为它们都表示最终剩下的数，所以f(n, m) = f'(n-1, m)。
     * 3. 将f'(n-1, m)的重排序列映射为f(n, m)的形式：
     *    k+1 -> 0,  k+2 -> 1, ... n-1 -> n-k-2, 0 -> n-k-1, 1 -> n-k, ... k-1 -> n-2
     * 将映射定义为:
     *    p(x) = (x-k-1)%n，
     * 则逆映射为:
     *    p-1(x) = (x+k+1)%n。
     * 由于映射后的序列和最初的序列形式相同，仍然使用f(n-1, m)表示。映射之前的序列中最后剩下的数字:
     *    f'(n-1, m) = p-1(f(n-1, m)) = (f(n-1, m)+k+1)%n
     * 将k = (m-1)%n代入上述方程：
     *    f(n, m) = f'(n-1, m) = (f(n-1, m) + (m-1)%n+1)%n = (f(n-1, m) + m)%n。
     *
     * 所以综上所述，可以总结递推公式为：
     *    1> 当n=1时，f(n, m) = 0;
     *    2> 当n>1时，f(n, m) = (f(n-1, m) + m)%n
     * */
    int lastRemaining3(int n, int m);
};


#endif //SWORDTOOFFER_LASTREMAINING_H
