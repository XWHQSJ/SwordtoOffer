//
// Created by Wanhui on 2/20/20.
//

#ifndef SWORDTOOFFER_CUTTINGROPE_H
#define SWORDTOOFFER_CUTTINGROPE_H

/*
 * 剑指offer 14-1 剪绳子
 *
 * 给你一根长度为 n 的绳子，
 * 请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），
 * 每段绳子的长度记为 k[0],k[1]...k[m] 。
 * 请问 k[0]*k[1]*...*k[m] 可能的最大乘积是多少？
 * 例如，当绳子的长度是8时，
 * 我们把它剪成长度分别为2、3、3的三段，
 * 此时得到的最大乘积是18。
 *
 * 示例 1：
 *
 * 输入: 2
 * 输出: 1
 * 解释: 2 = 1 + 1, 1 × 1 = 1
 *
 * 示例 2:
 *
 * 输入: 10
 * 输出: 36
 * 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36
 *
 * 提示：
 * 2 <= n <= 58
 * */


class Solution14_1 {
public:
    /*
     * 方法1 贪心算法
     * 该方法偏向于数学题法，需要多组计算后进行规律总结。
     * 个人觉得该博主讲的最好，非常容易理解：整数拆分 --
     * https://leetcode-cn.com/problems/integer-break/solution/343-zheng-shu-chai-fen-tan-xin-by-jyd/
     * 思路的核心是发现必须以3为除数，即乘积必须以3为底数，
     * 得到乘积公式：x^a*b，下面讨论余数即可：
     *
     * 当余数为0：正好为3的倍数，返回3^a
     * 当余数为1：由于1乘积后无作用，需要拿出一个3，将3+1转换为4，此时返回3^(a-1)*4
     * 当余数为2：直接返回3^a*2
     * */
    int cuttingRope(int n);


    /*
     * 方法2 动态规划
     * 要知道某个数，比如5拆分为哪几个整数的和，
     * 并且整数的乘积最大，那么我们只要知道4,3,2拆分后的乘积，
     * 并从中选出最大值即可，以此类推。
     * 这样使用递归方法：dp=max(dp,i*(n-i),i*cuttingRope(n-i))可解决。
     * 而动态规划方法里面常使用的记忆数组可以简化递归，
     * 将每次比较的最优结果存储在记忆数组中，参与下一轮的比较，
     * 最终得到全局最优的结果。
     * */
    int cuttingRope2(int n);
};


#endif //SWORDTOOFFER_CUTTINGROPE_H
