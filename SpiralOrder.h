//
// Created by Wanhui on 3/10/20.
//

#ifndef SWORDTOOFFER_SPIRALORDER_H
#define SWORDTOOFFER_SPIRALORDER_H

/*
 * 剑指offer 29 顺时针打印矩阵
 *
 * 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。
 *
 * 示例 1：
 *
 * 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
 * 输出：[1,2,3,6,9,8,7,4,5]
 *
 * 示例 2：
 *
 * 输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
 * 输出：[1,2,3,4,8,12,11,10,9,5,6,7]
 *
 * 限制：
 * 0 <= matrix.length <= 100
 * 0 <= matrix[i].length <= 100
 * */


#include <vector>

class Solution29 {
public:
    /*
     * 边界判断法
     *
     * 顺时针打印矩阵，即对矩阵顺时针遍历，
     * 矩阵是矩形的，所以需要考虑四个边界条件。
     *
     * 1. 首先设定上(up)下(down)左(left)右(right)四个边界，
     *    并分别初始化为up=left=0, down=行数, right=列数。
     * 2. 向右遍历到矩阵最右边的点，将这些点push到结果数组中，
     *    此时第一行已经遍历完，将上边界up更新，即up++，
     *    同时判断上下边界是否交错，交错则跳出循环，不交错则继续。
     * 3. 向下遍历到矩阵最下边的点，将这些点push到结果数组中，
     *    此时最右边一列已经遍历完，将右边界right更新，即right--，
     *    同时判断左右边界是否交错，交错则跳出循环，不交错则继续。
     * 4. 向左遍历到矩阵最左边的点，将这些点push到结果数组中，
     *    此时最下边的一行已经遍历完，将下边界down更新，即down--，
     *    同时判断左右边界是否交错，交错则跳出循环，不交错则继续。
     * 5. 向上遍历到矩阵的上边界最左边的点，将这些点push到结果数组中，
     *    此时最左边的一行已经遍历完，将左边界left更新，即left++，
     *    同时判断上下边界是否交错，交错则跳出循环，不交错则继续。
     * 6. 循环以上步骤，直到某两条边界交错，跳出循环，返回结果数组。
     * */
    std::vector<int> spiralOrder(std::vector<std::vector<int>> &matrix);
};


#endif //SWORDTOOFFER_SPIRALORDER_H
